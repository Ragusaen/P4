Package sablecc;

Helpers
    all = [0 .. 0xFFFF];
    anychar = ['A' .. 'Z'] | ['a' .. 'z'] | '_';
    digit = ['0' .. '9'];
    tab = 9;
    cr = 13;
    lf = 10;
    eol = cr lf | cr | lf | '\n';
    boolliteral = ('false'|'true'|'HIGH'|'LOW');
    intliteral = '-'?digit+;
    floatliteral = '-'?digit+'.'digit*|digit*'.'digit+;
    timeliteral = (digit*'.')?digit+('ms'|'s'|'m'|'h');
    stringliteral = '"'('\'all | [[all - '"'] - '\'])*'"';
    charliteral = '''('\'all | [[all - '''] - '\'])''';

Tokens
    stringtype = 'String';
    chartype = 'Char';
    inttype = 'Int';
    floattype = 'Float';
    booltype = 'Bool';
    timetype = 'Time';
    digitaloutputpintype = 'DigitalOutputPin';
    digitalinputpintype = 'DigitalInputPin';
    analogoutputpintype = 'AnalogOutputPin';
    analoginputpintype = 'AnalogInputPin';
    every = 'every';
    if = 'if';
    on = 'on';
    else = 'else';
    while = 'while';
    for = 'for';
    break = 'break';
    continue = 'continue';
    rising = 'rising';
    falling = 'falling';
    pin = 'pin';
    delay = 'delay';
    until = 'until';
    set = 'set';
    to = 'to';
    read = 'read';
    start = 'start';
    stop = 'stop';
    and = 'and';
    or = 'or';
    assign = '=';
    equal = '==';
    notequal = '!=';
    addition = '+';
    subtraction = '-';
    multiplication = '*';
    division = '/';
    modulo = '%';
    greaterthan = '>';
    lessthan = '<';
    greaterthanorequalto = '>=';
    lessthanorequalto = '<=';
    additionassign = '+=';
    subtractionassign = '-=';
    multiplicationassign = '*=';
    divisionassign = '/=';
    moduloassign = '%=';
    semicolon = ';';
    not = '!';
    colon = ':';
    comma = ',';
    return = 'return';
    template = 'template';
    fun = 'fun';
    module = 'module';
    lparen = '(';
    rparen = ')';
    lbrace = '{';
    rbrace = '}';
    lbracket = '[';
    rbracket = ']';
    boolliteral = ('false'|'true'|'HIGH'|'LOW');
    intliteral = '-'?digit+;
    floatliteral = '-'?digit+'.'digit*|digit*'.'digit+;
    timeliteral = (digit*'.')?digit+('ms'|'s'|'m'|'h');
    stringliteral = '"'('\'all | [[all - '"'] - '\'])*'"';
    charliteral = '''('\'all | [[all - '''] - '\'])''';
    identifier = anychar (anychar|digit)*;
    whitespace = (' ' | tab | lf | eol)+;
    comment = '/*' all* '*/' | '//'all*eol;

Ignored Tokens
    whitespace, comment;

Productions
    program = root_element*;

    root_element {-> root_element} =
        {dcl} dcl_stmt
            {-> New root_element.dcl(dcl_stmt.stmt)}
        | {module} moduledcl
            {-> New root_element.moduledcl(moduledcl)}
        | {function} functiondcl
            {-> New root_element.functiondcl(functiondcl)};

/* Function */
    functiondcl {-> functiondcl} =
        fun identifier lparen paramlist? rparen return_type? [body]:simple_stmt
            {-> New functiondcl(identifier, [paramlist.param], return_type.type, body.stmt)};

    return_type {-> type} =
        colon type
            {-> type};

    paramlist {-> param*} =
        type identifier paramtail*
            {-> [New param(identifier, type), paramtail.param]};

    paramtail {-> param} =
        comma type identifier
            {-> New param(identifier, type)};

    arglist {-> expr*} =
        expr argtail*
            {-> [expr, argtail.expr]};

    argtail {-> expr} =
        comma expr
            {-> expr};

/* Module */
    moduledcl {-> moduledcl} =
        {template} template module identifier params? inner_module
            {-> New moduledcl.template(identifier, [params.param], inner_module)}
        | {named} module identifier inner_module
            {-> New moduledcl.instance(identifier, inner_module)}
        | {anonymous_no_dcls} module_structure
            {-> New moduledcl.instance(Null, New inner_module([], module_structure))}
        | {anonymous_with_dcls} inner_module
            {-> New moduledcl.instance(Null, inner_module)};

    params {-> param*} =
        lparen paramlist rparen
            {-> [paramlist.param]};

    inner_module {-> inner_module} =
        lbrace dcl_stmt* module_structure rbrace
            {-> New inner_module([dcl_stmt.stmt], module_structure)};

    dcl_stmt {-> stmt} = dcl semicolon
        {-> dcl.stmt};

    module_structure {-> module_structure} =
        {every} every lparen expr rparen stmt
            {-> New module_structure.every(expr, stmt)}
        | {on_rising} on rising lparen expr rparen stmt
            {-> New module_structure.on(New statechange.rising(), expr, stmt)}
        | {on_falling} on falling lparen expr rparen stmt
            {-> New module_structure.on(New statechange.falling(), expr, stmt)};

/* Statement */
    stmt {-> stmt} =
        {matched} matched
            {-> matched.stmt}
        | {unmatched} unmatched
            {-> unmatched.stmt};

    matched {-> stmt} =
        {matched_if_else} if lparen expr rparen [if_body]:matched else [else_body]:matched
            {-> New stmt.if(expr, if_body.stmt, else_body.stmt)}
        | {while} while lparen [condition]:expr rparen [body]:matched
            {-> New stmt.while(condition, body.stmt)}
        | {for} for lparen [init]:single_stmt [a]:semicolon [condition]:expr [b]:semicolon [update]:single_stmt rparen [body]:matched
            {-> New stmt.for(init.stmt, condition, update.stmt, body.stmt)}
        | {simple_stmt} simple_stmt
            {-> simple_stmt.stmt};

    unmatched {-> stmt} =
        {unmatched_if_simple} if lparen expr rparen stmt
            {-> New stmt.if(expr, stmt, Null)}
        | {unmatched_if_else} if lparen expr rparen matched else unmatched
            {-> New stmt.if(expr, matched.stmt, unmatched.stmt)}
        | {while} while lparen [condition]:expr rparen [body]:unmatched
            {-> New stmt.while(condition, body.stmt)}
        | {for} for lparen [init]:single_stmt [a]:semicolon [condition]:expr [b]:semicolon [update]:single_stmt rparen [body]:unmatched
            {-> New stmt.for(init.stmt, condition, update.stmt, body.stmt)};

    simple_stmt {-> stmt} =
         {single_stmt} single_stmt semicolon
             {-> single_stmt.stmt}
         | {block} lbrace stmt* rbrace
              {-> New stmt.block([stmt])};

    single_stmt {-> stmt} =
        {dcl} dcl
            {-> dcl.stmt}
        | {assign} identifier assign expr
            {-> New stmt.assign(identifier, expr, Null)}
        | {set_to} set identifier to boolliteral
            {-> New stmt.set_to(identifier, boolliteral)}
        | {read} read identifier
            {-> New stmt.read(identifier)}
        | {additionassign} identifier additionassign expr
            {-> New stmt.assign(identifier, expr, New binop.addition())}
        | {subtractionassign} identifier subtractionassign expr
            {-> New stmt.assign(identifier, expr, New binop.subtraction())}
        | {divisionassign} identifier divisionassign expr
            {-> New stmt.assign(identifier, expr, New binop.division())}
        | {multiplicationassign} identifier multiplicationassign expr
            {-> New stmt.assign(identifier, expr, New binop.multiplication())}
        | {moduloassign} identifier moduloassign expr
            {-> New stmt.assign(identifier, expr, New binop.modulo())}
        | {start} start lparen identifier rparen
            {-> New stmt.start(identifier)}
        | {stop} stop
            {-> New stmt.stop()}
        | {delay} delay lparen expr rparen
            {-> New stmt.delay(expr)}
        | {delay_until} delay until lparen expr rparen
            {-> New stmt.delayuntil(expr)}
        | {return} return expr?
            {-> New stmt.return(expr)}
        | {function_call} identifier lparen arglist? rparen
            {-> New stmt.expr(New expr.function_call(identifier, [arglist.expr]))}
        | {break} break
            {-> New stmt.break()}
        | {continue} continue
            {-> New stmt.continue()}
        | {no_stmt}
            {-> New stmt.no_stmt()};

/* Declaration */
    dcl {-> stmt} =
        {vardcl} type vardcls
            {-> New stmt.dcl(type, [vardcls.vardcl])}
        | {module_dcl} module [template]:identifier [instance]:identifier arguments?
            {-> New stmt.moduledcl(template, instance, [arguments.expr])};

    arguments {-> expr*} =
        lparen arglist rparen
            {-> [arglist.expr]};

    vardcls {-> vardcl* } =
        varinit vardcls_tail*
            {-> [varinit.vardcl, vardcls_tail.vardcl]};

    vardcls_tail {-> vardcl} =
        comma varinit
            {-> varinit.vardcl};

    varinit {-> vardcl} =
        {no_init} identifier
            {-> New vardcl(identifier, Null)}
        | {init} identifier assign expr
            {-> New vardcl(identifier, expr)};

    type {-> type} =
        {string} stringtype {-> New type.string()}
        | {char} chartype {-> New type.char()}
        | {int} inttype {-> New type.int()}
        | {float} floattype {-> New type.float()}
        | {bool} booltype {-> New type.bool()}
        | {time} timetype {-> New type.time()}
        | {array} type lbracket indexlist rbracket {-> New type.array(type, indexlist)}
        | {digitaloutputpin} digitaloutputpintype {-> New type.digitaloutputpin()}
        | {digitalinputpin} digitalinputpintype {-> New type.digitalinputpin()}
        | {analogoutputpin} analogoutputpintype {-> New type.analogoutputpin()}
        | {analoginputpin} analoginputpintype {-> New type.analoginputpin()};

    indexlist {-> indexlist} =
        {empty} filler*
            {-> New indexlist.empty([filler])}
        | {filled} arglist
            {-> New indexlist.filled([arglist.expr])};

    filler {-> filler} =
        comma
            {-> New filler()};

/* Expression */
    expr {-> expr} =
        {pinexpr} pinexpr
            {-> pinexpr.expr};

    pinexpr {-> expr} =
        {pin} pin intliteral
            {-> New expr.pin(intliteral)}
        | {orexpr} orexpr
            {-> orexpr.expr};

    orexpr {-> expr} =
        {or} orexpr or andexpr
            {-> New expr.binop(orexpr.expr, New binop.or(), andexpr.expr)}
        | {andexpr} andexpr
            {-> andexpr.expr};

    andexpr {-> expr} =
        {and} andexpr and equalsexpr
            {-> New expr.binop(andexpr.expr, New binop.and(), equalsexpr.expr)}
        | {equalsexpr} equalsexpr
            {-> equalsexpr.expr};

    equalsexpr {-> expr} =
        {equals} equalsexpr equal relation
            {-> New expr.binop(equalsexpr.expr, New binop.equal(), relation.expr)}
        | {not_equals} equalsexpr notequal relation
            {-> New expr.unop(New unop.not(), New expr.binop(equalsexpr.expr, New binop.equal(), relation.expr))}
        | {relation} relation
            {-> relation.expr};

    relation {-> expr} =
        {greaterthan} relation greaterthan term
            {-> New expr.binop(relation.expr, New binop.greaterthan(), term.expr)}
        | {lessthan} relation lessthan term
            {-> New expr.binop(relation.expr, New binop.lessthan(), term.expr)}
        | {lessthanorequalto} relation lessthanorequalto term
            {-> New expr.unop(New unop.not(), New expr.binop(relation.expr, New binop.greaterthan(), term.expr))}
        | {greaterthanorequalto} relation greaterthanorequalto term
            {-> New expr.unop(New unop.not(), New expr.binop(relation.expr, New binop.lessthan(), term.expr))}
        | {term} term
            {-> term.expr};

    term {-> expr} =
        {addition} term addition factor
            {-> New expr.binop(term.expr, New binop.addition(), factor.expr)}
        | {subtraction} term subtraction factor
            {-> New expr.binop(term.expr, New binop.subtraction(), factor.expr)}
        | {factor} factor
            {-> factor.expr};

    factor {-> expr} =
        {multiplication} factor multiplication unary
            {-> New expr.binop(factor.expr, New binop.multiplication(), unary.expr)}
        | {division} factor division unary
            {-> New expr.binop(factor.expr, New binop.division(), unary.expr)}
        | {modulo} factor modulo unary
            {-> New expr.binop(factor.expr, New binop.modulo(), unary.expr)}
        | {unary} unary
            {-> unary.expr};

    unary {->expr} =
        {plus} addition parenthesis
            {-> New expr.unop(New unop.plus(), parenthesis.expr)}
        | {minus} subtraction parenthesis
            {-> New expr.unop(New unop.minus(), parenthesis.expr)}
        | {not} not parenthesis
            {-> New expr.unop(New unop.not(), parenthesis.expr)}
        | {parenthesis} parenthesis
            {->parenthesis.expr};

    parenthesis {-> expr} =
        {parenthesis} lparen expr rparen
            {-> expr}
        | {index} index
            {-> index.expr};

    index {-> expr} =
        {index} value lbracket expr rbracket
            {-> New expr.index(value.expr, expr)}
        | {value} value
            {-> value.expr};

    value {-> expr} =
        {identifier} identifier
            {-> New expr.value(New value.identifier(identifier))}
        | {function_call} identifier lparen arglist? rparen
            {-> New expr.function_call(identifier, [arglist.expr])}
        | {literal} literal
            {-> literal.expr};

    literal {-> expr} =
        {int} intliteral
            {-> New expr.value(New value.int(intliteral))}
        | {float} floatliteral
            {-> New expr.value(New value.float(floatliteral))}
        | {string} stringliteral
            {-> New expr.value(New value.string(stringliteral))}
        | {char} charliteral
            {-> New expr.value(New value.char(charliteral))}
        | {bool} boolliteral
            {-> New expr.value(New value.bool(boolliteral))}
        | {time} timeliteral
            {-> New expr.value(New value.time(timeliteral))}
        | {array} lbracket arglist rbracket
            {-> New expr.value(New value.array([arglist.expr]))};

Abstract Syntax Tree
    program = root_element*;
    root_element = {dcl} stmt | {moduledcl} moduledcl | {functiondcl} functiondcl;

/* Function */
    functiondcl = identifier param* type? [body]:stmt;
    param = identifier type;

/* Module */
    moduledcl = {template} identifier param* inner_module | {instance} identifier? inner_module;
    inner_module = [dcls]:stmt* module_structure;
    module_structure = {every} expr [body]:stmt | {on} statechange expr [body]:stmt;
    statechange = {rising} | {falling};

/* Statement */
    stmt = {no_stmt} | {dcl} type vardcl* | {moduledcl} [template]:identifier [instance]:identifier expr* | {start} identifier | {stop} |{read} identifier | {set_to} identifier boolliteral | {delay} expr | {delayuntil} expr | {assign} identifier expr binop? | {block} stmt* | {if} expr [if_body]:stmt [else_body]:stmt? | {while} [condition]:expr [body]:stmt | {for} [init]:stmt [condition]:expr [update]:stmt [body]:stmt | {expr} expr | {return} expr? | {break} | {continue};

/* Declaration subnodes */
    vardcl = identifier expr?;
    type = {string} | {char} | {int} | {float} | {bool} | {time} | {digitaloutputpin} | {digitalinputpin} | {analogoutputpin} | {analoginputpin} | {array} type [sizes]:indexlist;
    indexlist = {empty} filler* | {filled} expr*;
    filler = ;

/* Expression */
    expr = {binop} [l]:expr binop [r]:expr | {unop} unop expr | {function_call} identifier expr* | {value} value | {pin} intliteral | {index} [value]:expr [index]:expr;
    binop = {addition} | {subtraction} | {multiplication} | {division} | {modulo} | {or} | {and} | {equal} | {greaterthan} | {lessthan};
    unop = {minus} | {plus} | {not};
    value = {identifier} identifier | {int} intliteral | {float} floatliteral | {string} stringliteral | {char} charliteral | {bool} boolliteral | {time} timeliteral | {array} expr*;