Package sablecc;

Helpers
    all = [0 .. 0xFFFF];
    anychar = ['A' .. 'z'];
    digit = ['0' .. '9'];
    tab = 9;
    cr = 13;
    lf = 10;
    eol = cr lf | cr | lf | '\n';

Tokens
    stringtype = 'String';
    chartype = 'Char';
    inttype = 'Int';
    floattype = 'Float';
    booltype = 'Bool';
    timetype = 'Time';
    digitaloutputpintype = 'DigitalOutputPin';
    digitalinputpintype = 'DigitalInputPin';
    analogoutputpintype = 'AnalogOutputPin';
    analoginputpintype = 'AnalogInputPin';
    every = 'every';
    if = 'if';
    on = 'on';
    else = 'else';
    while = 'while';
    for = 'for';
    break = 'break';
    continue = 'continue';
    rising = 'rising';
    falling = 'falling';
    pin = 'pin';
    delay = 'delay';
    until = 'until';
    set = 'set';
    to = 'to';
    read = 'read';
    start = 'start';
    stop = 'stop';
    and = 'and';
    or = 'or';
    assign = '=';
    equal = '==';
    notequal = '!=';
    addition = '+';
    subtraction = '-';
    multiplication = '*';
    division = '/';
    modulo = '%';
    greaterthan = '>';
    lessthan = '<';
    additionassign = '+=';
    subtractionassign = '-=';
    multiplicationassign = '*=';
    divisionassign = '/=';
    moduloassign = '%=';
    greaterthanorequalto = '>=';
    lessthanorequalto = '<=';
    semicolon = ';';
    not = '!';
    colon = ':';
    comma = ',';
    return = 'return';
    template = 'template';
    fun = 'fun';
    module = 'module';
    lparen = '(';
    rparen = ')';
    lbrace = '{';
    rbrace = '}';
    lbracket = '[';
    rbracket = ']';
    boolliteral = ('false'|'true'|'HIGH'|'LOW');
    intliteral = '-'?digit+;
    floatliteral = '-'?digit+'.'digit*|digit*'.'digit+;
    timeliteral = (digit*'.')?digit+('ms'|'s'|'m'|'h');
    stringliteral = '"'('\'all | [[all - '"'] - '\'])*'"';
    charliteral = '''('\'all | [[all - '''] - '\'])''';
    identifier = anychar (anychar|digit)*;
    whitespace = (' ' | tab | lf | eol)+;
    comment = '/*' all* '*/' | '//'all*eol;

Ignored Tokens
    whitespace, comment;

Productions
    program = root_element*;

    root_element {-> root_element} =
        {dcl} dcl_stmt
            {-> New root_element.dcl(dcl_stmt.stmt)}
        | {module} moduledcl
            {-> New root_element.moduledcl(moduledcl)};

/* Module */
    moduledcl {-> moduledcl} =
        {template} template module identifier inner_module
            {-> New moduledcl.template(identifier, inner_module)}
        | {anonymous_no_dcls} module_structure
            {-> New moduledcl.anonymous(New inner_module([], module_structure))}
        | {anonymous_with_dcls} inner_module
            {-> New moduledcl.anonymous(inner_module)};

    inner_module {-> inner_module} =
        lbrace dcl_stmt* module_structure rbrace
            {-> New inner_module([dcl_stmt.stmt], module_structure)};

    dcl_stmt {-> stmt} = dcl semicolon
        {-> dcl.stmt};

    module_structure {-> module_structure} =
        {every} every lparen expr rparen stmt
            {-> New module_structure.every(expr, stmt)}
        | {on} on lparen expr rparen stmt
            {-> New module_structure.on(expr, stmt)};

/* Statement */
    stmt {-> stmt} =
        {single_stmt} single_stmt semicolon
            {-> single_stmt.stmt}
        | {block} lbrace stmt* rbrace
            {-> New stmt.block([stmt])}
        | {for} for lparen [init]:single_stmt [a]:semicolon [condition]:expr [b]:semicolon [update]:single_stmt rparen [body]:stmt
            {-> New stmt.for(init.stmt, condition, update.stmt, body)}
        | {while} while lparen [condition]:expr rparen [body]:stmt
            {-> New stmt.while(condition, body)};


    single_stmt {-> stmt} =
        {dcl} dcl
            {-> dcl.stmt}
        | {assign} identifier assign expr
            {-> New stmt.assign(identifier, expr)}
        | {additionassign} identifier additionassign expr
            {-> New stmt.additionassign(identifier, expr)}
        | {subtractionassign} identifier subtractionassign expr
            {-> New stmt.subtractionassign(identifier, expr)}
        | {divisionassign} identifier divisionassign expr
            {-> New stmt.divisionassign(identifier, expr)}
        | {multiplicationassign} identifier multiplicationassign expr
            {-> New stmt.multiplicationassign(identifier, expr)}
        | {moduloassign} identifier moduloassign expr
            {-> New stmt.moduloassign(identifier, expr)}
        | {start} start lparen identifier rparen
            {-> New stmt.start(identifier)}
        | {stop} stop
            {-> New stmt.stop()}
        | {delay} delay lparen expr rparen
            {-> New stmt.delay(expr)}
        | {no_stmt}
            {-> New stmt.no_stmt()};

/* Declaration */
    dcl {-> stmt} =
        type vardcls
            {-> New stmt.dcl(type, [vardcls.vardcl])};

    vardcls {-> vardcl* } =
        varinit vardcls_tail*
            {-> [varinit.vardcl, vardcls_tail.vardcl]};

    vardcls_tail {-> vardcl} =
        comma varinit
            {-> varinit.vardcl};

    varinit {-> vardcl} =
        {no_init} identifier
            {-> New vardcl(identifier, Null)}
        | {init} identifier assign expr
            {-> New vardcl(identifier, expr)};

    type {-> type} =
        {string} stringtype {-> New type.string()}
        | {char} chartype {-> New type.char()}
        | {int} inttype {-> New type.int()}
        | {float} floattype {-> New type.float()}
        | {bool} booltype {-> New type.bool()}
        | {time} timetype {-> New type.time()}
        | {digitaloutputpin} digitaloutputpintype {-> New type.digitaloutputpin()}
        | {digitalinputpin} digitalinputpintype {-> New type.digitalinputpin()}
        | {analogoutputpin} analogoutputpintype {-> New type.analogoutputpin()}
        | {analoginputpin} analoginputpintype {-> New type.analoginputpin()};

/* Expression */
    expr {-> expr} =
         {term} term
            {-> term.expr};

    term {-> expr} =
        {addition} expr addition factor
            {-> New expr.binop(expr, New binop.addition(), factor.expr)}
        | {subtraction} expr subtraction factor
            {-> New expr.binop(expr, New binop.subtraction(), factor.expr)}
        | {factor} factor
            {-> factor.expr};

    factor {-> expr} =
        {multiplication} factor multiplication unary
            {-> New expr.binop(factor.expr, New binop.multiplication(), unary.expr)}
        | {division} factor division unary
            {-> New expr.binop(factor.expr, New binop.division(), unary.expr)}
        | {modulo} factor modulo unary
            {-> New expr.binop(factor.expr, New binop.modulo(), unary.expr)}
        | {unary} unary
            {-> unary.expr};

    unary {->expr} =
        {plus} addition parenthesis
            {-> New expr.unop(New unop.plus(), parenthesis.expr)}
        | {minus} subtraction parenthesis
            {-> New expr.unop(New unop.minus(), parenthesis.expr)}
        | {not} not parenthesis
            {-> New expr.unop(New unop.not(), parenthesis.expr)}
        | {parenthesis} parenthesis
            {->parenthesis.expr};

    parenthesis {-> expr} =
        {parenthesis} lparen expr rparen
            {-> New expr.parenthesis(expr)}
        | {value} value
             {-> value.expr};

    value {-> expr} =
        {identifier} identifier
            {-> New expr.value(New value.identifier(identifier))}
        | {literal} literal
            {-> literal.expr};

    literal {-> expr} =
        {int} intliteral
            {-> New expr.value(New value.int(intliteral))}
        | {float} floatliteral
            {-> New expr.value(New value.float(floatliteral))}
        | {string} stringliteral
            {-> New expr.value(New value.string(stringliteral))}
        | {char} charliteral
            {-> New expr.value(New value.char(charliteral))}
        | {bool} boolliteral
            {-> New expr.value(New value.bool(boolliteral))}
        | {time} timeliteral
            {-> New expr.value(New value.time(timeliteral))};

Abstract Syntax Tree
    program = root_element*;
    root_element = {dcl} stmt | {moduledcl} moduledcl;

/* Module */
    moduledcl = {template} identifier inner_module | {anonymous} inner_module;
    inner_module = [dcls]:stmt* module_structure;
    module_structure = {every} expr [body]:stmt | {on} expr [body]:stmt;

/* Statement */
    stmt = {no_stmt} | {dcl} type vardcl* | {start} identifier | {stop} | {delay} expr | {assign} identifier expr | {additionassign} identifier expr | {subtractionassign} identifier expr | {divisionassign} identifier expr | {multiplicationassign} identifier expr | {moduloassign} identifier expr | {block} stmt* | {for} [init]:stmt [condition]:expr [update]:stmt [body]:stmt | {while} [condition]:expr [body]:stmt;

/* Declaration subnodes*/
    vardcl = identifier expr?;
    type = {string} | {char} | {int} | {float} | {bool} | {time} | {digitaloutputpin} | {digitalinputpin} | {analogoutputpin} | {analoginputpin};

/* Expression */
    expr = {binop} [l]:expr binop [r]:expr | {unop} unop expr | {parenthesis} expr | {value} value;
    binop = {addition} | {subtraction} | {multiplication} | {division} | {modulo};
    unop = {minus} | {plus} | {not};
    value = {identifier} identifier | {int} intliteral | {float} floatliteral | {string} stringliteral | {char} charliteral | {bool} boolliteral | {time} timeliteral;